import { IncomingHttpHeaders } from 'http';

declare type AuthorizeOptions = {
    /**
     * The secret API key for your Liveblocks account. You can find it on
     * https://liveblocks.io/dashboard/apikeys
     */
    secret: string;
    /**
     * The room ID for which to authorize the user. This will authorize the user
     * to enter the Liveblocks room.
     */
    room: string;
    /**
     * Associates a user ID to the session that is being authorized. The user ID
     * is typically set to the user ID from your own database.
     *
     * It can also be used to generate a token that gives access to a private
     * room where the userId is configured in the room accesses.
     *
     * This user ID will be used as the unique identifier to compute your
     * Liveblocks account's Monthly Active Users.
     */
    userId: string;
    /**
     * Arbitrary metadata associated to this user session.
     *
     * You can use it to store a small amount of static metadata for a user
     * session. It is public information, that will be visible to other users in
     * the same room, like name, avatar URL, etc.
     *
     * It's only suitable for static info that won't change during a session. If
     * you want to store dynamic metadata on a user session, don't keep that in
     * the session token, but use Presence instead.
     *
     * Can't exceed 1KB when serialized as JSON.
     */
    userInfo?: unknown;
    /**
     * Tell Liveblocks which group IDs this user belongs to. This will authorize
     * the user session to access private rooms that have at least one of these
     * group IDs listed in their room access configuration.
     *
     * See https://liveblocks.io/docs/guides/managing-rooms-users-permissions#permissions
     * for how to configure your room's permissions to use this feature.
     */
    groupIds?: string[];
};
declare type AuthorizeResponse = {
    status: number;
    body: string;
    error?: Error;
};
/**
 * Tells Liveblocks that a user should be allowed access to a room, which user
 * this session is for, and what metadata to associate with the user (like
 * name, avatar, etc.)
 *
 * @example
 * export default async function auth(req, res) {
 *
 * // Implement your own security here.
 *
 * const room = req.body.room;
 * const response = await authorize({
 *   room,
 *   secret,
 *   userId: "123",
 *   userInfo: {    // Optional
 *     name: "Ada Lovelace"
 *   },
 *   groupIds: ["group1"] // Optional
 * });
 * return res.status(response.status).end(response.body);
 * }
 */
declare function authorize(options: AuthorizeOptions): Promise<AuthorizeResponse>;

declare class WebhookHandler {
    private secretBuffer;
    private static secretPrefix;
    constructor(
    /**
     * The signing secret provided on the dashboard's webhooks page
     * @example "whsec_wPbvQ+u3VtN2e2tRPDKchQ1tBZ3svaHLm"
     */
    secret: string);
    /**
     * Verifies a webhook request and returns the event
     */
    verifyRequest(request: WebhookRequest): WebhookEvent;
    /**
     * Verifies the headers and returns the webhookId, timestamp and rawSignatures
     */
    private verifyHeaders;
    /**
     * Signs the content with the secret
     * @param content
     * @returns `string`
     */
    private sign;
    /**
     * Verifies that the timestamp is not too old or in the future
     */
    private verifyTimestamp;
    /**
     * Ensures that the event is a known event type
     * or throws and prompts the user to upgrade to a higher version of @liveblocks/node
     */
    private verifyWebhookEventType;
}
declare type WebhookRequest = {
    /**
     * Headers of the request
     * @example
     * {
     *  "webhook-id": "123",
     *  "webhook-timestamp": "1614588800000",
     *  "webhook-signature": "v1,bm9ldHUjKzFob2VudXRob2VodWUzMjRvdWVvdW9ldQo= v2,MzJsNDk4MzI0K2VvdSMjMTEjQEBAQDEyMzMzMzEyMwo="
     * }
     */
    headers: IncomingHttpHeaders;
    /**
     * Raw body of the request, do not parse it
     * @example '{"type":"storageUpdated","data":{"roomId":"my-room-id","appId":"my-app-id","updatedAt":"2021-03-01T12:00:00.000Z"}}'
     */
    rawBody: string;
};
declare type WebhookEvent = StorageUpdatedEvent | UserEnteredEvent | UserLeftEvent | RoomCreatedEvent | RoomDeletedEvent;
declare type StorageUpdatedEvent = {
    type: "storageUpdated";
    data: {
        roomId: string;
        appId: string;
        /**
         * ISO 8601 datestring
         * @example "2021-03-01T12:00:00.000Z"
         */
        updatedAt: string;
    };
};
declare type UserEnteredEvent = {
    type: "userEntered";
    data: {
        appId: string;
        roomId: string;
        connectionId: number;
        userId: string | null;
        userInfo: Record<string, unknown> | null;
        /**
         * ISO 8601 datestring
         * @example "2021-03-01T12:00:00.000Z"
         * @description The time when the user entered the room.
         */
        enteredAt: string;
        numActiveUsers: number;
    };
};
declare type UserLeftEvent = {
    type: "userLeft";
    data: {
        appId: string;
        roomId: string;
        connectionId: number;
        userId: string | null;
        userInfo: Record<string, unknown> | null;
        /**
         * ISO 8601 datestring
         * @example "2021-03-01T12:00:00.000Z"
         * @description The time when the user left the room.
         */
        leftAt: string;
        numActiveUsers: number;
    };
};
declare type RoomCreatedEvent = {
    type: "roomCreated";
    data: {
        appId: string;
        roomId: string;
        /**
         * ISO 8601 datestring
         * @example "2021-03-01T12:00:00.000Z"
         */
        createdAt: string;
    };
};
declare type RoomDeletedEvent = {
    type: "roomDeleted";
    data: {
        appId: string;
        roomId: string;
        /**
         * ISO 8601 datestring
         * @example "2021-03-01T12:00:00.000Z"
         */
        deletedAt: string;
    };
};

export { StorageUpdatedEvent, UserEnteredEvent, UserLeftEvent, WebhookEvent, WebhookHandler, WebhookRequest, authorize };
