"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/authorize.ts
var _nodefetch = require('node-fetch'); var _nodefetch2 = _interopRequireDefault(_nodefetch);
function authorize(options) {
  return __async(this, null, function* () {
    try {
      const { room, secret, userId, userInfo, groupIds } = options;
      if (!(typeof room === "string" && room.length > 0)) {
        throw new Error(
          "Invalid room. Please provide a non-empty string as the room. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize"
        );
      }
      if (!(typeof userId === "string" && userId.length > 0)) {
        throw new Error(
          "Invalid userId. Please provide a non-empty string as the userId. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize"
        );
      }
      const resp = yield _nodefetch2.default.call(void 0, buildLiveblocksAuthorizeEndpoint(options, room), {
        method: "POST",
        headers: {
          Authorization: `Bearer ${secret}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          userId,
          userInfo,
          groupIds
        })
      });
      if (resp.ok) {
        return {
          status: 200,
          body: yield resp.text()
        };
      }
      if (resp.status >= 500) {
        return {
          status: 503,
          body: yield resp.text()
        };
      } else {
        return {
          status: 403,
          body: yield resp.text()
        };
      }
    } catch (er) {
      return {
        status: 503,
        body: 'Call to "https://api.liveblocks.io/v2/rooms/:roomId/authorize" failed. See "error" for more information.',
        error: er
      };
    }
  });
}
function buildLiveblocksAuthorizeEndpoint(options, roomId) {
  if (options.liveblocksAuthorizeEndpoint) {
    return options.liveblocksAuthorizeEndpoint.replace("{roomId}", roomId);
  }
  return `https://api.liveblocks.io/v2/rooms/${encodeURIComponent(
    roomId
  )}/authorize`;
}

// src/webhooks.ts
var _crypto = require('crypto'); var _crypto2 = _interopRequireDefault(_crypto);
var _WebhookHandler = class {
  constructor(secret) {
    if (!secret)
      throw new Error("Secret is required");
    if (typeof secret !== "string")
      throw new Error("Secret must be a string");
    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)
      throw new Error("Invalid secret, must start with whsec_");
    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);
    this.secretBuffer = Buffer.from(secretKey, "base64");
  }
  /**
   * Verifies a webhook request and returns the event
   */
  verifyRequest(request) {
    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(
      request.headers
    );
    this.verifyTimestamp(timestamp);
    const signature = this.sign(`${webhookId}.${timestamp}.${request.rawBody}`);
    const expectedSignatures = rawSignatures.split(" ").map((rawSignature) => {
      const [, parsedSignature] = rawSignature.split(",");
      return parsedSignature;
    }).filter(isNotUndefined);
    if (expectedSignatures.includes(signature) === false)
      throw new Error(
        `Invalid signature, expected one of ${expectedSignatures.join(
          ", "
        )}, got ${signature}`
      );
    const event = JSON.parse(request.rawBody);
    this.verifyWebhookEventType(event);
    return event;
  }
  /**
   * Verifies the headers and returns the webhookId, timestamp and rawSignatures
   */
  verifyHeaders(headers) {
    const sanitizedHeaders = {};
    Object.keys(headers).forEach((key) => {
      sanitizedHeaders[key.toLowerCase()] = headers[key];
    });
    const webhookId = sanitizedHeaders["webhook-id"];
    if (typeof webhookId !== "string")
      throw new Error("Invalid webhook-id header");
    const timestamp = sanitizedHeaders["webhook-timestamp"];
    if (typeof timestamp !== "string")
      throw new Error("Invalid webhook-timestamp header");
    const rawSignatures = sanitizedHeaders["webhook-signature"];
    if (typeof rawSignatures !== "string")
      throw new Error("Invalid webhook-signature header");
    return { webhookId, timestamp, rawSignatures };
  }
  /**
   * Signs the content with the secret
   * @param content
   * @returns `string`
   */
  sign(content) {
    return _crypto2.default.createHmac("sha256", this.secretBuffer).update(content).digest("base64");
  }
  /**
   * Verifies that the timestamp is not too old or in the future
   */
  verifyTimestamp(timestampHeader) {
    const now = Math.floor(Date.now() / 1e3);
    const timestamp = parseInt(timestampHeader, 10);
    if (isNaN(timestamp)) {
      throw new Error("Invalid timestamp");
    }
    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp too old");
    }
    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp in the future");
    }
  }
  /**
   * Ensures that the event is a known event type
   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node
   */
  verifyWebhookEventType(event) {
    if (event && event.type && [
      "storageUpdated",
      "userEntered",
      "userLeft",
      "roomCreated",
      "roomDeleted"
    ].includes(event.type))
      return;
    throw new Error(
      "Unknown event type, please upgrade to a higher version of @liveblocks/node"
    );
  }
};
var WebhookHandler = _WebhookHandler;
WebhookHandler.secretPrefix = "whsec_";
var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
var isNotUndefined = (value) => value !== void 0;



exports.WebhookHandler = WebhookHandler; exports.authorize = authorize;
